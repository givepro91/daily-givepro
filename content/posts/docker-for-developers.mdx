---
title: "Docker 입문: 개발 환경을 컨테이너로 관리하기"
description: "Docker의 기본 개념부터 개발 환경 구축까지, 개발자를 위한 Docker 실전 입문 가이드입니다."
date: "2026-02-09"
category: "tech"
tags: ["Docker", "DevOps", "개발환경", "컨테이너"]
enableAds: true
---

"내 컴퓨터에서는 되는데?" 이 말은 개발자들 사이에서 유명한 밈입니다. 개발 환경과 배포 환경의 차이로 인해 발생하는 문제는 모든 팀이 겪는 고질적인 문제입니다. Docker는 이 문제를 근본적으로 해결합니다.

이 글에서는 Docker의 기본 개념부터 실제 개발 환경에서 활용하는 방법까지 단계별로 설명합니다.

## Docker란 무엇인가?

Docker는 애플리케이션을 컨테이너라는 격리된 환경에서 실행할 수 있게 해주는 도구입니다. 컨테이너 안에는 애플리케이션과 그에 필요한 모든 의존성(라이브러리, 런타임, 시스템 도구)이 함께 패키징됩니다.

### 컨테이너 vs 가상 머신

가상 머신(VM)은 전체 운영체제를 에뮬레이션하므로 무겁고 시작이 느립니다. 반면 컨테이너는 호스트 OS의 커널을 공유하므로 훨씬 가볍고 빠릅니다.

- **가상 머신**: 수 GB 크기, 부팅에 수 분 소요, OS 라이선스 필요
- **컨테이너**: 수 MB~수백 MB, 수 초 만에 시작, OS 공유

### 핵심 용어

- **이미지(Image)**: 컨테이너를 만들기 위한 설계도. 읽기 전용입니다.
- **컨테이너(Container)**: 이미지를 기반으로 생성된 실행 가능한 인스턴스.
- **Dockerfile**: 이미지를 빌드하기 위한 명세서. 단계별로 환경을 구성합니다.
- **Docker Hub**: Docker 이미지를 공유하는 레지스트리. npm이 JavaScript 패키지 저장소인 것처럼 Docker Hub는 이미지 저장소입니다.

## Docker 설치

### Mac에서 설치

Docker Desktop for Mac을 공식 사이트에서 다운로드합니다. Apple Silicon(M1/M2/M3/M4)과 Intel 모두 지원합니다.

설치 후 터미널에서 확인합니다.

```bash
docker --version
docker compose version
```

### 리소스 설정

Docker Desktop의 Settings > Resources에서 CPU, 메모리, 디스크 할당량을 조정할 수 있습니다. 기본값으로 시작하되, 컨테이너를 많이 실행할 경우 메모리를 4GB 이상으로 설정하는 것을 권장합니다.

<InArticleAd />

## Dockerfile 작성법

Dockerfile은 이미지를 빌드하는 레시피입니다. Node.js 애플리케이션용 Dockerfile을 예시로 살펴보겠습니다.

```dockerfile
# 베이스 이미지 선택
FROM node:20-alpine

# 작업 디렉토리 설정
WORKDIR /app

# 의존성 파일 복사 (캐시 활용을 위해 먼저)
COPY package.json package-lock.json ./

# 의존성 설치
RUN npm ci

# 소스 코드 복사
COPY . .

# 빌드
RUN npm run build

# 포트 노출
EXPOSE 3000

# 실행 명령
CMD ["npm", "start"]
```

### 레이어 캐싱 이해하기

Dockerfile의 각 명령어는 레이어를 만듭니다. Docker는 변경되지 않은 레이어를 캐시에서 재사용합니다. 그래서 자주 변경되는 파일(소스 코드)은 나중에, 덜 변경되는 파일(package.json)은 먼저 복사하는 것이 빌드 속도를 높이는 핵심입니다.

### .dockerignore

빌드 컨텍스트에서 제외할 파일을 `.dockerignore`에 정의합니다.

```
node_modules
.next
.git
*.md
.env*
```

## 필수 Docker 명령어

### 이미지 관련

```bash
# 이미지 빌드
docker build -t my-app .

# 이미지 목록
docker images

# 이미지 삭제
docker rmi my-app
```

### 컨테이너 관련

```bash
# 컨테이너 실행
docker run -p 3000:3000 my-app

# 백그라운드 실행
docker run -d -p 3000:3000 my-app

# 실행 중인 컨테이너 확인
docker ps

# 컨테이너 중지
docker stop 컨테이너ID

# 컨테이너 로그 확인
docker logs 컨테이너ID
```

### 자주 쓰는 옵션

- `-p 3000:3000`: 호스트의 3000 포트를 컨테이너의 3000 포트에 매핑
- `-d`: 백그라운드에서 실행 (detached mode)
- `-v $(pwd):/app`: 호스트 디렉토리를 컨테이너에 마운트 (볼륨)
- `--rm`: 컨테이너 종료 시 자동 삭제
- `--name my-container`: 컨테이너에 이름 지정

## Docker Compose로 멀티 컨테이너 관리

실제 애플리케이션은 여러 서비스(앱 서버, 데이터베이스, 캐시 등)로 구성됩니다. Docker Compose는 여러 컨테이너를 하나의 설정 파일로 관리할 수 있게 해줍니다.

```yaml
# docker-compose.yml
services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
    depends_on:
      - db
    volumes:
      - .:/app
      - /app/node_modules

  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: mydb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

### Compose 명령어

```bash
# 모든 서비스 시작
docker compose up

# 백그라운드 실행
docker compose up -d

# 서비스 중지
docker compose down

# 로그 확인
docker compose logs -f

# 특정 서비스 재시작
docker compose restart app
```

## 개발 환경에서의 활용

### 핫 리로드 설정

개발 중에는 코드를 수정할 때마다 컨테이너를 재빌드하면 비효율적입니다. 볼륨 마운트를 사용하면 로컬 파일 변경이 컨테이너에 즉시 반영됩니다.

```yaml
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    volumes:
      - .:/app
      - /app/node_modules  # node_modules는 컨테이너 것을 사용
    ports:
      - "3000:3000"
```

### 데이터베이스 관리

로컬에 PostgreSQL, MySQL 등을 직접 설치하는 대신 Docker로 관리하면 여러 장점이 있습니다. 프로젝트마다 다른 버전의 데이터베이스를 사용할 수 있고, 필요 없을 때 깨끗하게 제거할 수 있습니다.

## 보안 베스트 프랙티스

- **루트가 아닌 사용자로 실행**: `USER node` 지시문 추가
- **최소한의 베이스 이미지 사용**: `alpine` 기반 이미지 선호
- **시크릿을 이미지에 포함하지 않기**: 환경 변수나 Docker secrets 사용
- **멀티 스테이지 빌드**: 빌드 도구를 최종 이미지에서 제거

```dockerfile
# 멀티 스테이지 빌드 예시
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/package*.json ./
RUN npm ci --omit=dev
USER node
EXPOSE 3000
CMD ["npm", "start"]
```

## 마무리

Docker는 현대 개발 워크플로우에서 필수 도구가 되었습니다. 처음에는 명령어가 복잡해 보이지만, 기본 개념을 이해하고 자주 쓰는 명령어만 익히면 금방 편해집니다.

Docker Compose를 사용하면 프로젝트의 전체 개발 환경을 코드로 정의할 수 있습니다. 새로운 팀원이 합류해도 `docker compose up` 한 줄이면 동일한 개발 환경이 구축됩니다. 이것이 Docker의 진정한 가치입니다.
