---
title: "React Hooks 완벽 가이드: useState부터 커스텀 훅까지"
description: "React의 핵심 Hooks를 실전 예제와 함께 정리합니다. 초보자도 이해할 수 있는 Hooks 완벽 가이드."
date: "2026-02-07"
category: "tutorial"
tags: ["React", "Hooks", "프론트엔드", "JavaScript"]
enableAds: true
---

React Hooks는 함수 컴포넌트에서 상태 관리와 부수 효과를 처리할 수 있게 해주는 기능입니다. 2019년 React 16.8에서 도입된 이후 클래스 컴포넌트를 거의 완전히 대체했습니다. 이 글에서는 React의 핵심 Hooks를 실전 예제와 함께 체계적으로 정리합니다.

## useState - 상태 관리의 기본

`useState`는 가장 기본적인 Hook으로, 컴포넌트에 상태 변수를 추가합니다.

```typescript
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <button onClick={() => setCount(prev => prev - 1)}>-1</button>
    </div>
  );
}
```

### 주요 패턴

**함수형 업데이트**: 이전 상태를 기반으로 새 상태를 계산할 때 콜백 함수를 사용합니다. 이 패턴은 비동기 업데이트에서 안전합니다.

```typescript
setCount(prev => prev + 1); // 이전 값 기반으로 업데이트
```

**객체 상태 업데이트**: 객체를 상태로 사용할 때는 스프레드 연산자로 불변성을 유지해야 합니다.

```typescript
const [user, setUser] = useState({ name: "", email: "" });

// 특정 필드만 업데이트
setUser(prev => ({ ...prev, name: "Jay" }));
```

**초기값 지연 계산**: 초기값 계산이 비용이 큰 경우 함수를 전달하면 최초 렌더링에서만 실행됩니다.

```typescript
const [data, setData] = useState(() => {
  return expensiveComputation();
});
```

## useEffect - 부수 효과 처리

`useEffect`는 데이터 페칭, 구독, DOM 조작 등 컴포넌트 외부와 상호작용하는 작업에 사용합니다.

```typescript
import { useEffect, useState } from "react";

function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    async function fetchUser() {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      setUser(data);
    }
    fetchUser();
  }, [userId]); // userId가 변경될 때만 실행

  if (!user) return <p>Loading...</p>;
  return <p>{user.name}</p>;
}
```

### 의존성 배열의 이해

- **`[]` (빈 배열)**: 마운트 시 한 번만 실행
- **`[a, b]`**: a 또는 b가 변경될 때 실행
- **배열 생략**: 매 렌더링마다 실행 (보통 원하지 않는 동작)

### 클린업 함수

이벤트 리스너, 타이머, 구독 등을 정리할 때 클린업 함수를 반환합니다.

```typescript
useEffect(() => {
  const handleResize = () => setWidth(window.innerWidth);
  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);
```

<InArticleAd />

## useRef - DOM 접근과 값 유지

`useRef`는 두 가지 용도로 사용됩니다.

### DOM 요소 접근

```typescript
function TextInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus</button>
    </div>
  );
}
```

### 렌더링 사이에서 값 유지

`useRef`로 생성된 값은 변경되어도 리렌더링을 트리거하지 않습니다. 타이머 ID, 이전 값 저장 등에 활용합니다.

```typescript
function Timer() {
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const start = () => {
    intervalRef.current = setInterval(() => {
      console.log("tick");
    }, 1000);
  };

  const stop = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
  };

  return (
    <div>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
    </div>
  );
}
```

## useMemo와 useCallback - 성능 최적화

### useMemo

비용이 큰 계산 결과를 메모이제이션합니다.

```typescript
function ProductList({ products, query }: Props) {
  const filteredProducts = useMemo(() => {
    return products.filter(p =>
      p.name.toLowerCase().includes(query.toLowerCase())
    );
  }, [products, query]);

  return (
    <ul>
      {filteredProducts.map(p => <li key={p.id}>{p.name}</li>)}
    </ul>
  );
}
```

### useCallback

함수 레퍼런스를 메모이제이션합니다. 자식 컴포넌트에 콜백을 전달할 때 불필요한 리렌더링을 방지합니다.

```typescript
function Parent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);

  return <Child onClick={handleClick} />;
}
```

### 최적화 주의사항

`useMemo`와 `useCallback`은 만능이 아닙니다. 모든 곳에 사용하면 오히려 메모이제이션 오버헤드가 발생합니다. 다음 경우에만 사용하세요.

- 계산이 실제로 비용이 큰 경우
- `React.memo`로 감싸진 자식 컴포넌트에 전달하는 경우
- 의존성 배열이 다른 Hook에 사용되는 경우

## useContext - 전역 상태 공유

`useContext`는 props drilling 없이 컴포넌트 트리 전체에서 값을 공유합니다.

```typescript
// 컨텍스트 생성
const ThemeContext = createContext<"light" | "dark">("light");

// Provider로 값 제공
function App() {
  const [theme, setTheme] = useState<"light" | "dark">("light");

  return (
    <ThemeContext.Provider value={theme}>
      <Main />
    </ThemeContext.Provider>
  );
}

// 어디서든 값 사용
function Button() {
  const theme = useContext(ThemeContext);
  return (
    <button className={theme === "dark" ? "bg-black" : "bg-white"}>
      Click me
    </button>
  );
}
```

## 커스텀 Hook 만들기

반복되는 로직을 커스텀 Hook으로 추출하면 코드 재사용성이 크게 향상됩니다.

### useLocalStorage

로컬 스토리지와 동기화되는 상태를 관리하는 Hook입니다.

```typescript
function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch {
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    const valueToStore = value instanceof Function ? value(storedValue) : value;
    setStoredValue(valueToStore);
    window.localStorage.setItem(key, JSON.stringify(valueToStore));
  };

  return [storedValue, setValue] as const;
}

// 사용
const [theme, setTheme] = useLocalStorage("theme", "light");
```

### useDebounce

입력값에 디바운스를 적용하는 Hook입니다. 검색 입력 등에 유용합니다.

```typescript
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}

// 사용
function Search() {
  const [query, setQuery] = useState("");
  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (debouncedQuery) {
      searchAPI(debouncedQuery);
    }
  }, [debouncedQuery]);
}
```

## Hooks 규칙

React Hooks에는 반드시 지켜야 할 두 가지 규칙이 있습니다.

1. **최상위에서만 호출**: 조건문, 반복문, 중첩 함수 안에서 호출하면 안 됩니다.
2. **React 함수에서만 호출**: 일반 JavaScript 함수가 아닌 React 컴포넌트나 커스텀 Hook에서만 호출합니다.

ESLint의 `eslint-plugin-react-hooks` 플러그인을 사용하면 이 규칙 위반을 자동으로 감지할 수 있습니다.

## 마무리

React Hooks는 컴포넌트 로직을 직관적이고 재사용 가능하게 만들어줍니다. `useState`, `useEffect`, `useRef`만 확실히 이해해도 대부분의 React 개발이 가능합니다. 나머지 Hook과 커스텀 Hook은 필요한 상황이 생겼을 때 학습하면 됩니다.

핵심은 각 Hook의 목적을 이해하고, 적절한 상황에서 사용하는 것입니다. 무분별하게 최적화 Hook을 남발하기보다는 먼저 간단하게 구현하고, 실제 성능 문제가 발생할 때 최적화하는 접근이 바람직합니다.
